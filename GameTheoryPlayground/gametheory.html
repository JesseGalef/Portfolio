<!DOCTYPE html>
<html>
	<head>
		<style>

			.dot {
			  stroke: #000;
			}
			.tooltip {
			  position: absolute;
			  width: 200px;
			  height: 28px;
			  pointer-events: none;
			}

			.path { 
			    /*stroke: steelblue;*/
			    stroke-width: 2;
			    fill: none;
			}


		</style>
		<script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
		<script>


			// var agent1;
			// var agent2;
			function Agent(moves, memory, payoffs, learningRate, mutationRate){
				if (moves === undefined) {moves = ['C','D'];};
				if (memory === undefined) {memory = 2;};
				if (payoffs === undefined) {payoffs = {'CC': 3, 'CD': 0, 'DC': 5, 'DD': 1};};
				if (learningRate === undefined) {learningRate = 0.25;};
				if (mutationRate === undefined) {mutationRate = 0.025;};

				this.moves = moves;
				this.learningRate = learningRate;
				this.mutationRate = mutationRate;
				this.payoffs = payoffs;
				this.memory = memory;
				this.score = 0;
				this.strategyDict = {};
				this.traits = {}; // can be set after a season with this.setTraits()
				this.startingRecentPast = [];
				this.recentPast = [];
				this.dotColor = 'rgb(0,0,0)';
				for (i=0; i<this.memory; i++){
					this.startingRecentPast.push('--');
					this.recentPast.push('--');
				};
				this.myMoveHistory = {};
				this.moveCount = 0;
				this.theirMoveHistory = {};
				
				this.offspringStrategyDict = {}; // used to store the upcoming Dict
				this.maxPayoff = 0;
				this.minPayoff = 0;

				this.setRandomStrategy = function(){
					strategies = createStrategyList(this.memory, Object.keys(this.payoffs));
					this.strategyDict = {};
					for (i in strategies){
						this.strategyDict[strategies[i]] = moves[Math.floor(Math.random()*moves.length)];
					};// end of i 
				};
				this.setRandomStrategy();
				this.outcomeHistory = {};

				this.setTFT = function(){
					for (strategy in this.strategyDict){
						lastCharacter = strategy[strategy.length - 1];
						this.strategyDict[strategy] = lastCharacter;
					};
					this.strategyDict[this.startingRecentPast] = this.moves[0];
					this.dotColor = 'rgb(0,128,255)';
					this.learningRate = 0;
					this.mutationRate = 0;
				};

				// greedy = function(strategy, move){
				// 	return ((strategy[strategy.length-1]=='C') && (move=='D'));
				// };

				// punishing = function(strategy, move){
				// 	return ((strategy[strategy.length-1] == 'D') && (move=='D'));
				// };




				this.setTraits = function(){
					traits = {
						'greedy': {'acted': 0, 'possible': 0},
						'punishing': {'acted': 0, 'possible': 0},
						'forgiving': {'acted': 0, 'possible': 0}};

					for (strategy in this.strategyDict){
						if (strategy[strategy.length-1] == 'D'){
							traits['punishing']['possible'] += this.outcomeHistory[strategy];
							if (this.strategyDict[strategy] == 'D'){
								traits['punishing']['acted'] += this.outcomeHistory[strategy];
							};
						};

						if (strategy[strategy.length-1] == 'C'){
							traits['greedy']['possible'] += this.outcomeHistory[strategy];
							if (this.strategyDict[strategy] == 'D'){
								traits['greedy']['acted'] += this.outcomeHistory[strategy];
							};
						};

						if (strategy[strategy.length-4] == 'D' && 
							strategy[strategy.length-1] == 'C'){
							traits['forgiving']['possible'] += this.outcomeHistory[strategy];
							if (this.strategyDict[strategy] == 'C'){
								traits['forgiving']['acted'] += this.outcomeHistory[strategy];
							};
						};
					};

					this.traits = traits;
				};

				this.describeTraits = function(){
					this.setTraits();
					traitString = '<p>';
					for (trait in this.traits){
						traitString += trait + ': ' + traits[trait]['acted'] + 
									   ' out of ' + traits[trait]['possible'] + '<br />';
					};
					traitString += 'Score: ' + this.score.toFixed(2);
					traitString += '</p>';
					return traitString;
				};//end of describeTraits function

				this.addHistory = function(mine, theirs, outcome){
					this.myMoveHistory[mine] += 1;
					this.theirMoveHistory[theirs] += 1;
					this.moveCount += 1;
					if (outcome in this.outcomeHistory){
						this.outcomeHistory[outcome] += 1;
					}
					else {
						this.outcomeHistory[outcome] = 1;
					};
				}; // end of addHistory function


				this.evolve = function(partnerStrategyDict){
					this.offspringStrategyDict = {};
					for (strategy in this.strategyDict){
						whichParent = Math.random();
						if (whichParent < .5){
							this.offspringStrategyDict[strategy] = this.strategyDict[strategy];
						}
						else{
							this.offspringStrategyDict[strategy] = partnerStrategyDict[strategy];
						};
					};
				};// end of evolve function

				this.mutate = function(){
					for (strategy in this.strategyDict){
						if (Math.random() < this.mutationRate){
							this.strategyDict[strategy] = this.moves[Math.floor(Math.random()*this.moves.length)];
						}
					};//
				};

				this.resetMemory = function(){
					for (outcome in this.recentPast){
						this.recentPast[outcome] = this.startingRecentPast[outcome];
					};
				};
				this.reset = function(){
					this.resetMemory();
					for (move in this.moves){
						this.myMoveHistory[this.moves[move]] = 0;
						this.theirMoveHistory[this.moves[move]] = 0;
					};
					this.outcomeHistory = {};
					for (strategy in this.strategyDict){
						this.outcomeHistory[strategy] = 0;
					};

					this.score = 0;
					this.moveCount = 0;
				};// end of reset function

				this.reset();

			};

			function Game(moves, memory, payoffs, learningRate, mutationRate, deathPoint){
				
				if (moves === undefined) {moves = ['C','D'];};
				if (memory === undefined) {memory = 2;};
				if (payoffs === undefined) {payoffs = {'CC': 3, 'CD': 0, 'DC': 5, 'DD': 1};};
				if (learningRate === undefined) {learningRate = 0.5;};
				if (mutationRate === undefined) {mutationRate = 0.025;};
				if (deathPoint === undefined) {deathPoint = -1;};

				this.moves = moves;
				this.payoffs = payoffs;
				this.memory = memory;
				this.learningRate = learningRate;
				this.mutationRate = mutationRate;

				this.agentList = [];
				this.outcomeHistory = {};
				this.traitHistory = [];
				this.scoreDistribution = {};
				this.strategyAverages = {};
				this.iterations = 0;

				this.defaultStrategyList = createStrategyList(this.memory, Object.keys(this.payoffs));
				for (strategyIndex in this.defaultStrategyList){
					this.outcomeHistory[this.defaultStrategyList[strategyIndex]] = 0;
				};

				this.strategyList = createStrategyList(this.memory, Object.keys(this.payoffs));

				this.createAgents = function (n_agents) {
					for (agentCreation=0; agentCreation<n_agents; agentCreation++){
						nextAgent = new Agent(moves=this.moves,
											  memory=this.memory,
											  payoffs=this.payoffs,
											  learningRate=this.learningRate,
											  mutationRate=this.mutationRate);
						this.agentList.push(nextAgent);
					};//end of agentCreation for loop
				};// end of createAgents function

				this.createTFT = function(n_agents) {
					if (n_agents===undefined) {n_agents=1;};
					for (n=0; n < n_agents; n++){
						this.createAgents(1);
						this.agentList[this.agentList.length-1].setTFT();
					};
				};

				this.interaction = function(agent1, agent2){
					if (agent1.recentPast in this.outcomeHistory) {
						this.outcomeHistory[agent1.recentPast] += 1;
						this.outcomeHistory[agent2.recentPast] += 1;
					}
					else{
						this.outcomeHistory[agent1.recentPast] = 1;
						this.outcomeHistory[agent2.recentPast] = 1;
					};// This shouldn't be necessary, look to remove

					agent1Move = agent1.strategyDict[agent1.recentPast];
					agent2Move = agent2.strategyDict[agent2.recentPast];
					agent1.score = agent1.score + this.payoffs[agent1Move+agent2Move];
					agent2.score = agent2.score + this.payoffs[agent2Move+agent1Move];
					agent1.addHistory(agent1Move, agent2Move, agent1.recentPast);
					agent2.addHistory(agent2Move, agent1Move, agent2.recentPast);

					agent1.recentPast.push(agent1Move+agent2Move);
					agent1.recentPast.shift();
					agent2.recentPast.push(agent2Move+agent1Move);
					agent2.recentPast.shift();					

				};

				this.repeatedInteraction = function(agent1, agent2, n_rounds){
					if (n_rounds===undefined) {n_rounds=50;};
					agent1.resetMemory();
					agent2.resetMemory();

					for (round=0; round<n_rounds; round++){
						this.interaction(agent1, agent2);
					};//end of round for loop
				};// End of repeatedInteraction function

				this.roundRobin = function(n_rounds){
					if (n_rounds===undefined) {n_rounds=50;};

					for (agent1Index=0; agent1Index<this.agentList.length; agent1Index++){
						for (agent2Index=agent1Index+1; agent2Index<this.agentList.length; agent2Index++){
							agent1 = this.agentList[agent1Index];
							agent2 = this.agentList[agent2Index];
							this.repeatedInteraction(agent1, agent2, n_rounds);
						};// end of agent2Index for loop
					};// end of agent1Index for loop
				}; // end of roundRobin function
				
				this.randomPairings = function(n_interactions, n_rounds){
					if (n_interactions===undefined || n_interactions==0) {n_interactions=this.agentList.length;};
					if (n_rounds===undefined) {n_rounds=50;};

					for (interaction=0; interaction<n_interactions; interaction++){
						for (agent1Index in this.agentList){
							agent2Index = agent1Index;
							while (agent2Index == agent1Index){
								agent2Index = Math.floor(Math.random()*this.agentList.length);
							};
							this.repeatedInteraction(this.agentList[agent1Index], this.agentList[agent2Index], n_rounds)
						};// end of agent1Index for loop
					};
				};// end of randomPairings function

				this.addTraitHistory = function(){
					thisYearTraits = {};
					for (agentIndex in this.agentList){
						agent = this.agentList[agentIndex];
						for (trait in agent.traits){
							if (!(trait in thisYearTraits)){
								thisYearTraits[trait] = {'acted': 0, 'possible': 0};
							};
							thisYearTraits[trait]['acted'] += agent.traits[trait]['acted'];
							thisYearTraits[trait]['possible'] += agent.traits[trait]['possible'];
						};// each trait
					};// each agent
					this.traitHistory.push(thisYearTraits);
				};

				this.setAggregateInfo = function(){
					// has changed into strategy count (later normalized to be avg)

					scoreDistribution = {};
					strategyAverages = {};

					for (strategyIndex in this.strategyList){
						strategy = this.strategyList[strategyIndex];
						scoreDistribution[strategy] = {};
						strategyAverages[strategy] = 0;
						for (moveIndex in this.moves){
							scoreDistribution[strategy][this.moves[moveIndex]]=0;
						}
					};

					for (agentIndex in this.agentList){
						agent = this.agentList[agentIndex];
						for (strategy in agent.strategyDict){
							if (agent.strategyDict[strategy] == agent.moves[0]){
								strategyAverages[strategy] += 1;
							};
							scoreDistribution[strategy][agent.strategyDict[strategy]] += agent.score;
						};// end of for strategyIndex in agent.strategyDict loop
					};// end of for agentIndex loop

					for (strategy in scoreDistribution){
						// total = 0;
					
						// total += scoreDistribution[strategy][this.moves[move]];
						if (strategyAverages[strategy] == 0){
							scoreDistribution[strategy][this.moves[0]] = null;
							scoreDistribution[strategy][this.moves[1]] /= this.agentList.length;
						}
						else if (strategyAverages[strategy] == this.agentList.length){
							scoreDistribution[strategy][this.moves[0]] /= this.agentList.length;
							scoreDistribution[strategy][this.moves[1]] = null;
						}
						else{
							scoreDistribution[strategy][this.moves[0]] /= strategyAverages[strategy];
							scoreDistribution[strategy][this.moves[1]] /= (this.agentList.length - strategyAverages[strategy]);
						};
						strategyAverages[strategy] /= this.agentList.length;
					
						// for (move in this.moves){
						// 	scoreDistribution[strategy][this.moves[move]] /= total;
						// };
					};

					sortedScoreDistribution = [];
					
					for (strategy in scoreDistribution){
						score1 = scoreDistribution[strategy][this.moves[0]];
						score2 = scoreDistribution[strategy][this.moves[1]];
						if (!(score1 == null) && !(score2 == null)){
							scoreDiff = score1 - score2;
							for (insertionIndex = 0;
									insertionIndex < sortedScoreDistribution.length;
									insertionIndex++){
								comparisonScoreDiff = sortedScoreDistribution[insertionIndex][this.moves[0]] - sortedScoreDistribution[insertionIndex][this.moves[1]];
								if (scoreDiff > comparisonScoreDiff) {
									break;
								};

							}; // insertionIndex is the index to put strategy

							if (insertionIndex == sortedScoreDistribution.length){
								sortedScoreDistribution.push(scoreDistribution[strategy]);
								sortedScoreDistribution[insertionIndex]['strategy'] = strategy;
							}
							else{
								sortedScoreDistribution.splice(insertionIndex, 0, scoreDistribution[strategy]);
								sortedScoreDistribution[insertionIndex]['strategy'] = strategy;
							};
						};// Neither value was null
					};
						
					this.sortedScoreDistribution = sortedScoreDistribution;
					this.scoreDistribution = scoreDistribution;
					this.strategyAverages = strategyAverages;
				};// end of setAggregateInfo function

				this.evolveAgents = function(){
					agentScores = [];
					totalScore = 0;
					for (agentIndex in this.agentList){
						agent = this.agentList[agentIndex];
						agentScores.push(agent.score);
						totalScore += agent.score;
					}; 
					for (agentIndex in this.agentList){
						agent = this.agentList[agentIndex];
						// Pick a partner randomly, weighted by score
						partnerIndex = agentIndex;
						while (partnerIndex == agentIndex){
							rand = Math.random();
							diminishingScore = rand * totalScore;
							for (selectionIndex=0; selectionIndex<this.agentList.length; selectionIndex++){
								diminishingScore -= agentScores[selectionIndex];
								if (diminishingScore < 0){break;};
							};
							partnerIndex = selectionIndex;	
						};						
						this.agentList[agentIndex].evolve(this.agentList[partnerIndex].strategyDict);
					};
						
					for (agentIndex in this.agentList){
						agent = this.agentList[agentIndex];
						agent.strategyDict = agent.offspringStrategyDict;
						agent.mutate();
					};
				};// end of evolveAgents function

				this.setScoreRange = function(){
					payoffValues = [];
					for (payoff in this.payoffs){
						payoffValues.push(this.payoffs[payoff]);
					};
					this.minPayoff = Math.min.apply(Math, payoffValues);
					this.maxPayoff = Math.max.apply(Math, payoffValues);
				};
				this.setScoreRange();

				this.showRatios = function(){
					data = this.getRatios();
					rScale = d3.scale.sqrt()
			    		.domain([this.minPayoff, this.maxPayoff])
			    		.range([1,10]);

			    	rValue = function(d) {return d['score'];};
			    	rMap = function(d) { return rScale(rValue(d));};

			    	cMap = function(d) {return d['dotColor'];};



			    	if (document.getElementById('ratioCheckBox').checked){
				    	yScale.domain([0,1]);
				    	yMap = function(d) { return yScale(d['got']);};
			    	}else{
				    	yScale.domain([this.minPayoff, this.maxPayoff]);
				    	yMap = function(d) { return yScale(d.score);};
					};


					


					displayedDots = svg.selectAll("circle")
					.data(this.getRatios())
					.enter().append("circle")
					.attr("r", rMap)
					.attr("cx", xMap)
					.attr("cy", yMap)
					.attr("fill", cMap)
					.on("mouseover", function(d) {
					          tooltip.transition()
					               .duration(200)
					               .style("opacity", 1)
					               .style('background-color', 'rgba(255,255,255,1)')
					               .style('height', 'auto')
					               .style('border', '1px black');
					          tooltip.html(d['tooltipOutput'])
					               .style("left", (d3.event.pageX + 15) + "px")
					               .style("top", (d3.event.pageY - 28) + "px");
					      })
					      .on("mouseout", function(d) {
					          tooltip.transition()
					               .duration(300)
					               .style("opacity", 0);
					      });

				}; // end of showRatios function
				
				this.updateDots = function(){
					this.showRatios(); // Enters any data points not already created
					ratios = this.getRatios();
					
					var dots = svg
						.selectAll("circle")
						.data(ratios);


					yScale.domain()
					dots.transition().duration(750)
					.attr('cx', xMap)
					.attr('cy', yMap)
					.attr("r", rMap);

					dots.exit().remove();
				};//end of updateDots function


				this.showStats = function(){
					toShow = '';
					for (outcome in this.outcomeHistory){
						toShow = toShow + "<br />" + outcome + ": " + this.outcomeHistory[outcome];
					};
					document.getElementById('stats_p').innerHTML = toShow;
				};


				this.prepareStrategyCanvas = function() {

					barSvgWidth = 400;
					labelWidth = 100;
					barSvgHeight = 400;

					barSvg = d3.select('#strategies_div').append('svg')
							.attr('width', barSvgWidth)
							.attr('height', barSvgHeight);

					bars = barSvg.append('g');
					labels = barSvg.append('g');

					yBarScale = d3.scale.ordinal()
								  .domain(d3.entries(this.sortedScoreDistribution).map(function(d) {return d.key}))
								  .rangeBands([0,barSvgHeight],.2);

					yBarValue = function(d) {return d.key;};
					yBarMap = function(d) {return yBarScale(yBarValue(d));};


					xBarScale = d3.scale.linear()
								.domain([-this.maxPayoff, this.maxPayoff])
								.range([0, barSvgWidth]);

					moveList = this.moves;

					xBarValue = function(d) {
						scoreDiff = d.value[moveList[0]] - d.value[moveList[1]];
						if (scoreDiff < 0)
							{
								return scoreDiff;
							}else{
								return 0;
							};
					};

					xBarMap = function(d) {
						xVal = xBarValue(d);
						if (xBarValue(d) <0){
							return xBarScale(xVal) - labelWidth/2;
						}
						else{
							return xBarScale(xVal) + labelWidth/2;
						};
					};

					wBarScale = d3.scale.linear()
								.domain([0, this.maxPayoff])
								.range([0, barSvgWidth/2]);
					wBarValue = function(d) {return Math.abs(d.value[moveList[0]] - d.value[moveList[1]]);};
					wBarMap = function(d) {return wBarScale(wBarValue(d));};

				};

				this.showStrategies = function(){
					if (this.iterations == 0){
						this.prepareStrategyCanvas();
					};

					theseBars = bars.selectAll('rect')
						.data(d3.entries(this.sortedScoreDistribution));

					theseBars.enter().append('rect')
						.attr('x', xBarMap)
						.attr('y', yBarMap)
						.attr('height', function(d){
							return yBarScale.rangeBand();})
						.attr('width', wBarMap);

					theseBars.exit().remove();

					theseBars.transition().duration(500)
						.attr('x', xBarMap)
						.attr('y', yBarMap)
						.attr('width', wBarMap);

					theseLabels = labels
						.selectAll('text')
						.data(d3.entries(this.sortedScoreDistribution))

					theseLabels.enter().append('text')
						.attr('text-anchor', 'middle')
						// .attr('x', xBarScale(0))
						// .attr('y', yBarMap)
						.attr('transform', function(d,i){
							xTranslate = xBarScale(0);
							yTranslate = yBarScale(d.key);
							return "translate(" + xTranslate + ", "+ yTranslate +")";})
						.attr('dy', '1em')
						.text(function (d){return d.value.strategy});
						// .attr('dy', '1.1em')

					theseLabels.exit().remove();


					theseLabels.transition().duration(500)
						.text(function (d){return d.value.strategy});

				};

				this.prepareLinesCanvas = function(){
					linesSvg = d3.select("#lines_div").append("svg")
							.attr("width", 300)
							.attr("height", 300);

				    xLinesScale = d3.scale.linear()
				    	.domain([0,1])
				    	.range([0, 300]); // value -> display

				    yLinesScale = d3.scale.linear()
				    	.range([300,0])
				    	.domain([0,1]);

					lineSets = {};
					traitColors = {'greedy': 'rgb(0,255,0)', 'forgiving': 'rgb(0,0,255)', 'punishing':'rgb(255,0,0)'};


					for (trait in this.traitHistory[this.iterations]){
						lineSets[trait] = linesSvg
							.append('path')
							.attr('class', 'path')
							.attr('stroke', traitColors[trait]);
					};
						

				};// end of function prepareLinesCanvas

				this.drawLines = function(){
					if (this.iterations == 0){
						this.prepareLinesCanvas();
					};

					xLinesScale.domain([0, this.iterations+1]);
					for (trait in lineSets){
						theseLines = lineSets[trait];

						lineFunction = d3.svg.line()
							.x(function(d,i) {return xLinesScale(i); })
							.y(function(d) {
								if (d[trait].possible > 0){
									return yLinesScale(d[trait].acted / d[trait].possible);
								}else{
									return yLineScale(0);
								};
							});

						theseLines
						.attr('d', lineFunction(this.traitHistory));
					};

					
				};

				this.resetAgents = function(){
					for (agentIndex in this.agentList){
						this.agentList[agentIndex].reset();
					};
				};// end of resetAgents function

				this.normalizeAgentScores = function(){
					for (agentIndex in this.agentList){
						agent = this.agentList[agentIndex];
						agent.score /= agent.moveCount;
					};
				};

				this.setAgentTraits = function(){
					for (agentIndex in this.agentList){
						this.agentList[agentIndex].setTraits();
					}
				};

				this.resetOutcomeHistory = function(){
					for (outcome in this.outcomeHistory){
						this.outcomeHistory[outcome] = 0;
					};

				};

				this.season = function(){
					if (this.iterations > 0) {
						this.evolveAgents();
						this.resetAgents();
						this.resetOutcomeHistory();
					};

					this.randomPairings();
					this.normalizeAgentScores();
					this.setAgentTraits();
					this.setAggregateInfo();
					this.addTraitHistory();
					if (document.getElementById('checkBox').checked){
						this.updateDots();
						// this.showStats();
						this.showStrategies();
						this.drawLines();
					}
					else{
						if (this.iterations == 0){
							this.prepareLinesCanvas();
							this.prepareStrategyCanvas()
						};
					};
					this.iterations += 1;

				};

				this.getRatios = function(){
					agentData = [];
					for (agentIndex in this.agentList){
						agent = this.agentList[agentIndex];
						myMoveCount = agent.myMoveHistory[agent.moves[0]];
						theirMoveCount = agent.theirMoveHistory[agent.moves[0]];
						total = agent.moveCount;
						agentData.push({
							'did': myMoveCount / total,
							'got': theirMoveCount / total,
							'score': agent.score,
							'dotColor': agent.dotColor,
							'tooltipOutput': agent.describeTraits(),
							'index': agentIndex
						});
					};// end of for agentIndex loop
					return agentData;
				};// end of getRatios function
			};// end of Game function


			function createStrategyList(memory, outcomes){
				if (memory===undefined) {memory=2;};
				if (outcomes===undefined) {outcomes=['CC', 'CD', 'DC', 'DD'];};

				allStrats= [];
				for (level=0; level<=memory; level++){
					n_outcomes = level;
					n_blank = memory-level;
					for (i=0; i<(Math.pow(4,n_outcomes)); i++){
						thisStrategy = [];
						if (n_outcomes > 0){
							b = i.toString(4);
							while (b.length < n_outcomes){
								b = "0" + b;
							};// added leading 0's
							for (char=0; char<b.length; char++){
								thisStrategy.push(outcomes[parseInt(b[char])]);
							};//end of char in b loop
						};
						for (blanks=0; blanks<n_blank; blanks++){
							thisStrategy = ['--'].concat(thisStrategy);
						};// added all blanks to the front
						allStrats.push(thisStrategy);
					};// end of i for loop, for each strategy at level
				};// end of level for loop
				return allStrats;
			};//end of createStrategyList function
			
		</script>
	</head>
	<body>
		<div id='controls_div' style='width: 800px; display: block; clear: both;'>
			<button id='nextSeason' onclick='game.season()'>Next Season</button>
			<input id="checkBox" type="checkbox" checked>
			<label for='checkBox'>Display</label>

			<input id="ratioCheckBox" type="checkbox" checked>
			<label for='checkBox'>Ratio</label>
		</div>

		<div id='scatter_div' style='width: 400px; float: left; border: 1px solid black;'></div>
		<div id='strategies_div' style='height: auto; width: 400px; float: left'></div>

		<div id='lines_div' style='height: auto; width: 400px; clear: both;'></div>
		<script>

			function prepareRatioCanvas(){
				tooltip = d3.select("body").append("div")
				    .attr("class", "tooltip")
				    .style("opacity", 0);

				var margin = {top: 10, right: 10, bottom: 60, left: 60};
				var width = 400;
				var height = 400;
				var padding = 10;

				svg = d3.select("#scatter_div").append("svg")
						.attr("width", width)
						.attr("height", height)
						.append("g");
						// .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

				xValue = function(d) { return d['did'];}; // data -> value
			    xScale = d3.scale.linear().range([margin.left+padding, (width - margin.right)-padding]); // value -> display
			    xMap = function(d) { return xScale(xValue(d));}; // data -> display

				yValue = function(d) { return d['got'];}; // data -> value
			    yScale = d3.scale.linear().range([height - margin.bottom - padding, margin.top+padding]);
			    yMap = function(d) { return yScale(yValue(d));}; // data -> display
				
				xAxisYValue = height - margin.bottom;
				yAxisElement = svg.append("g").attr("class", "y axis")
					.attr("transform", "translate("+margin.left+", 0)");
				xAxisElement = svg.append("g").attr("class", 'x axis')
					.attr("transform", "translate(0, " + xAxisYValue + ")");

				xAxis = d3.svg.axis().scale(xScale).orient("bottom");
			    yAxis = d3.svg.axis().scale(yScale).orient("left");
				    
			    yAxisElement.call(yAxis)
			      .append("text")
			      .attr("class", "label")
			      .attr("transform", "rotate(-90)")
			      // .attr("y", 6)
			      .attr("y", '-2.5em')
			      .attr('x', -height/2)
			      .style("text-anchor", "middle")
			      .text("%Partner Cooperated");

			    xAxisElement.call(xAxis)
			      .append("text")
			      .attr("class", "label")
			      .attr("x", width/2)
			      .attr('y', '2.5em')
			      .style("text-anchor", "middle")
			      .text("%Cooperated w/ Partner");
			};// end of function prepareRatioCanvas

			prepareRatioCanvas();
			

			game = new Game();
			game.createAgents(20);

		</script>
		
	</body>
</html>
